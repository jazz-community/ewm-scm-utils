/*******************************************************************************
 * Copyright (c) 2015-2020 IBM Corporation
 *
 * This software may be modified and distributed under the terms
 * of the MIT license.  See the LICENSE file for details.
 * 
 *******************************************************************************/
package com.ibm.js.team.supporttools.framework;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.CommandLineParser;
import org.apache.commons.cli.GnuParser;
import org.apache.commons.cli.MissingArgumentException;
import org.apache.commons.cli.Options;
import org.apache.commons.cli.ParseException;
import org.apache.commons.cli.UnrecognizedOptionException;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.ibm.js.team.supporttools.framework.commands.ICommandFactory;
import com.ibm.js.team.supporttools.framework.framework.ICommand;

/**
 * Main class that is called and controls the execution.
 * 
 */
public abstract class AbstractSupportToolsFramework {

	public static final Logger logger = LoggerFactory.getLogger(AbstractSupportToolsFramework.class);

	ICommandFactory commandFactory = null;

	public AbstractSupportToolsFramework(final ICommandFactory commandFactory) {
		super();
		this.commandFactory = commandFactory;
	}

	/**
	 * Execute the command
	 * 
	 * @param args
	 * @throws ParseException
	 */
	public boolean execute(final String[] args) throws ParseException {

		boolean result = false;
		CommandLine cmd = null;
		Options options = new Options();
		options.addOption(SupportToolsFrameworkConstants.PARAMETER_COMMAND, true,
				SupportToolsFrameworkConstants.PARAMETER_COMMAND_EXAMPLE);
		try {

			// Parse the command line
			CommandLineParser cliParser = new GnuParser();
			// ignore unrecognized options, we only care for other issues,
			cmd = cliParser.parse(options, args, true);
		} catch (ParseException e) {
			if (e instanceof MissingArgumentException) {
				logger.error("Missing command \n" + "Syntax: -command commandName {[-parameter] [parameterValue]}");
				printSupportedCommands();
				return result;
			}
			if (!(e instanceof UnrecognizedOptionException)) {
				logger.info("Failed.");
				throw (e);
			}
		}

		// Get the command name provided as option
		String command = cmd.getOptionValue(SupportToolsFrameworkConstants.PARAMETER_COMMAND);
		if (command == null) {
			logger.error("Missing command \n\nSyntax: -command commandName {[-parameter] [parameterValue]}");
			printSupportedCommands();
			return result;
		}

		// get the class to execute
		ICommand execCommand = getCommandFactory().getCommandMap().get(command);
		if (execCommand == null) {
			logger.error("Unsupported command name '{}' \n", command);
			printSupportedCommands();
			return result;
		}

		// run the command
		result = execCommand.run(options, args);
		return result;
	}

	/**
	 * Print the syntax.
	 */
	public void printSupportedCommands() {
		logger.error("Available commands: \n");
		getCommandFactory().printCommandSyntax();
	}

	public ICommandFactory getCommandFactory() {
		return commandFactory;
	}
}
# Define the root logger with appender file
log = ./log4j
log4j.rootLogger = INFO, FILE , CONSOLE

# Define the file appender
log4j.appender.FILE=org.apache.log4j.FileAppender
log4j.appender.FILE.File=${log}/log.out

# Define the layout for file appender
log4j.appender.FILE.layout=org.apache.log4j.PatternLayout
log4j.appender.FILE.layout.conversionPattern=%m%n

# Define the file appender
log4j.appender.CONSOLE=org.apache.log4j.ConsoleAppender
log4j.appender.CONSOLE.Target=System.out

# Define the layout for file appender
log4j.appender.CONSOLE.layout=org.apache.log4j.PatternLayout
log4j.appender.CONSOLE.layout.conversionPattern=%m%n

/*******************************************************************************
 * Copyright (c) 2015-2020 IBM Corporation
 *
 * This software may be modified and distributed under the terms
 * of the MIT license.  See the LICENSE file for details.
 * 
 *******************************************************************************/
package com.ibm.js.team.supporttools.framework.commands;

import java.util.Collection;
import java.util.HashMap;

import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.ibm.js.team.supporttools.framework.framework.ICommand;

/**
 * Factory class dealing with commands. A new command has to be added to the
 * constructor.
 *
 */
public abstract class AbstractCommandFactory implements ICommandFactory {

	public static final Logger logger = LoggerFactory.getLogger(AbstractCommandFactory.class);
	private HashMap<String, ICommand> commandMap = new HashMap<String, ICommand>();

	/**
	 * Creates the list of supported commands
	 */
	public AbstractCommandFactory() {
		super();
		setAvailableCommands();
		// Enable sample command
		// put(new SampleCommandCmd());
	}

	public abstract void setAvailableCommands();

	/**
	 * Add a command to the list of supported commands
	 * 
	 * @param cmd
	 */
	public void put(final ICommand cmd) {
		commandMap.put(cmd.getCommandName(), cmd);
	}

	/**
	 * Print the syntax for all supported commands
	 */
	public void printCommandSyntax() {
		Collection<ICommand> commands = commandMap.values();
		for (ICommand iCommand : commands) {
			iCommand.printSyntax();
			logger.info("\n");
		}
	}

	/**
	 * @return the commandMap, never null
	 */
	public HashMap<String, ICommand> getCommandMap() {
		return commandMap;
	}

	/**
	 * Get a command by its name
	 * 
	 * @param commandName
	 * @return command or null
	 */
	public ICommand getCommand(final String commandName) {
		return commandMap.get(commandName);
	}

}

/*******************************************************************************
 * Copyright (c) 2015-2020 IBM Corporation
 *
 * This software may be modified and distributed under the terms
 * of the MIT license.  See the LICENSE file for details.
 * 
 *******************************************************************************/
package com.ibm.js.team.supporttools.framework.scenario;

import java.io.ByteArrayInputStream;
import java.io.IOException;
import java.io.InputStream;
import java.io.StringReader;
import java.net.URI;
import java.net.URISyntaxException;

import org.apache.commons.io.IOUtils;

import com.ibm.team.repository.client.ITeamRepository;
import com.ibm.team.repository.common.IContent;
import com.ibm.team.repository.common.TeamRepositoryException;
import com.ibm.team.repository.common.json.JSONObject;
import com.ibm.team.repository.common.transport.TeamServiceException;
import com.ibm.team.repository.transport.client.ITeamRawRestServiceClient.IRawRestClientConnection;
import com.ibm.team.repository.transport.client.ITeamRawRestServiceClient.IRawRestClientConnection.Response;

/**
 * Service to execute a start and stop for an expensive scenario.
 * 
 * Uses JSON instead of x-www-form-urlencoded to make parsing easier.
 * 
 * The information to stop the expensive scenario is returned as a string.
 *
 */
public class ExpensiveScenarioService implements IExpensiveScenarioService {

	private static final String EXPENSIVE_SCENARIO_START_PATH = "/service/com.ibm.team.repository.service.serviceability.IScenarioRestService/scenarios/startscenario";
	private static final String EXPENSIVE_SCENARIO_STOP_PATH = "/service/com.ibm.team.repository.service.serviceability.IScenarioRestService/scenarios/stopscenario";
	private static final String ACCEPT_HEADER = "Accept";
	private static final String APPLICATION_JSON = "application/json";
	private static final String SCENARIO_NAME = "scenarioName";
	private static final String SCENARIO_INSTANCE_ID = "scenarioInstanceId";

	static final String START_COMMAND = "start";
	static final String STOP_COMMAND = "stop";

	private URI fPublicURI = null;
	private ITeamRepository fTeamRepository;
	private String fScenarioName;

	/**
	 * Start and stop expensive scenario counter are performed persisting the
	 * scenario counter in a file or pass it as string. See option
	 * persistStartAsFile.
	 * 
	 * @param teamRepository
	 *            Team repository
	 * @param scenarioName
	 *            the name of the scenario
	 * @throws URISyntaxException
	 */
	public ExpensiveScenarioService(final ITeamRepository teamRepository, final String scenarioName)
			throws URISyntaxException, NullPointerException {
		if (teamRepository == null)
			throw new NullPointerException("TeamRepository can not be null");
		fTeamRepository = teamRepository;
		String publicURI = teamRepository.getRepositoryURI();
		if (publicURI == null)
			throw new NullPointerException("Public URI can not be null");
		fPublicURI = new URI(publicURI.replaceAll("/$", ""));
		if (scenarioName == null)
			throw new NullPointerException("Scenario name can not be null");
		fScenarioName = scenarioName;
	}

	/**
	 * Start and stop expensive scenario counter are performed persisting the
	 * scenario counter in a file or pass it as string. See option
	 * persistStartAsFile.
	 * 
	 * @param teamRepository
	 *            Team repository
	 * @param publicURI
	 *            Public URI of the target CLM server
	 * @param scenarioName
	 *            the name of the scenario
	 * @throws URISyntaxException
	 */
	public ExpensiveScenarioService(final ITeamRepository teamRepository, final String publicURI,
			final String scenarioName) throws URISyntaxException, NullPointerException {
		if (teamRepository == null)
			throw new NullPointerException("TeamRepository can not be null");
		fTeamRepository = teamRepository;
		if (publicURI == null)
			throw new NullPointerException("Public URI can not be null");
		fPublicURI = new URI(publicURI.replaceAll("/$", ""));
		if (scenarioName == null)
			throw new NullPointerException("Scenario name can not be null");
		fScenarioName = scenarioName;
	}

	/**
	 * Construct the service URI from the public URI.
	 * 
	 * @param path
	 * @return
	 */
	private URI getServiceURI(String path) {
		return URI.create(fPublicURI.toString() + path);
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.ibm.js.team.monitoring.custom.expensivescenario.
	 * IExpensiveScenarioService#start()
	 */
	public String start() throws Exception {
		Response response = null;
		try {
			// Compose the request body
			String body = "{\"" + SCENARIO_NAME + "\"" + ":" + "\"" + fScenarioName + "\"}";

			// Get the connection
			URI startUri = getServiceURI(EXPENSIVE_SCENARIO_START_PATH);
			IRawRestClientConnection connection = fTeamRepository.getRawRestServiceClient().getConnection(startUri);
			// Encode the start request
			byte[] data = body.getBytes(IContent.ENCODING_UTF_8);
			InputStream content = new ByteArrayInputStream(data);
			// Request JSON to make parsing easier
			connection.addRequestHeader(ACCEPT_HEADER, APPLICATION_JSON);
			// We are sending JSON as content type
			connection.doPost(content, data.length, APPLICATION_JSON);
			// Get the response back
			response = connection.getResponse();
			int status = response.getStatusCode();
			if (status == 200) {
				String responseString = IOUtils.toString(response.getResponseStream(), IContent.ENCODING_UTF_8);
				// System.out.println(responseString);
				JSONObject json = JSONObject.parse(new StringReader(responseString));
				String scenarioName = null;
				if (json.containsKey(SCENARIO_NAME)) {
					scenarioName = (String) json.get(SCENARIO_NAME);
				}
				if (scenarioName.equals(fScenarioName)) {
					return responseString;
				}
				throw new Exception("Unexpected Response Body '" + responseString + "'");
			}
			throw new Exception("Unexpected Response Code '" + status + "'");
		} finally {
			if (response != null) {
				response.close();
			}
		}
	}

	/*
	 * (non-Javadoc)
	 * 
	 * @see com.ibm.js.team.monitoring.custom.expensivescenario.
	 * IExpensiveScenarioService#stop(java.lang.String)
	 */
	public void stop(String startRequestResponse)
			throws URISyntaxException, TeamServiceException, TeamRepositoryException, IOException, Exception {
		Response response = null;
		try {
			String startRequest = startRequestResponse;
			String scenarioInstanceID;
			if (null == startRequest) {
				throw new Exception("Missing Scenario Start Request");
			}
			try {
				// Parse as JSON to get the scenario ID and the scenario name
				// from the file
				JSONObject json = JSONObject.parse(new StringReader(startRequest));
				String scenarioName = null;
				if (json.containsKey(SCENARIO_NAME)) {
					scenarioName = (String) json.get(SCENARIO_NAME);
				}
				scenarioInstanceID = null;
				if (json.containsKey(SCENARIO_INSTANCE_ID)) {
					scenarioInstanceID = (String) json.get(SCENARIO_INSTANCE_ID);
				}
				if (!fScenarioName.equals(scenarioName)) {
					throw new Exception("Incorrect Scenario Name Exception");
				}
			} catch (Exception e) {
				throw new Exception("Error Parsing Scenario Start Request '" + startRequest + "'");
			}
			// Create the stop request
			URI stopUri = getServiceURI(EXPENSIVE_SCENARIO_STOP_PATH);
			IRawRestClientConnection connection = fTeamRepository.getRawRestServiceClient().getConnection(stopUri);

			// create the request content
			byte[] data = startRequest.getBytes(IContent.ENCODING_UTF_8);
			InputStream content = new ByteArrayInputStream(data);

			// Request JSON to make parsing easier
			connection.addRequestHeader(ACCEPT_HEADER, APPLICATION_JSON);
			connection.doPost(content, data.length, APPLICATION_JSON);

			// process the result
			response = connection.getResponse();
			int status = response.getStatusCode();
			if (status == 200) {
				String responseString = IOUtils.toString(response.getResponseStream(), IContent.ENCODING_UTF_8);
				if (responseString != null) {
					// System.out.println(responseString);
					if (responseString.equals("\"" + scenarioInstanceID + "\"")) {
						return;
					}
					throw new Exception("Response Body Scenario Mismatch Exception");
				}
				throw new Exception("Missing Response Body Exception");
			}
			throw new Exception("Unexpected Response Code '" + status + "'");
		} finally {
			if (response != null) {
				response.close();
			}
		}
	}

	@Override
	public Object getScenarioName() {
		return fScenarioName;
	}
}
/*******************************************************************************
 * Copyright (c) 2015-2020 IBM Corporation
 *
 * This software may be modified and distributed under the terms
 * of the MIT license.  See the LICENSE file for details.
 * 
 *******************************************************************************/
package com.ibm.js.team.supporttools.framework.commands;

import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.Options;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;

import com.ibm.js.team.supporttools.framework.SupportToolsFrameworkConstants;
import com.ibm.js.team.supporttools.framework.framework.AbstractCommand;
import com.ibm.js.team.supporttools.framework.framework.ICommand;

/**
 * 
 * This class represents a minimal sample for a custom command.
 * 
 * To extend the tool with a new command, you must implement {@link ICommand }.
 * 
 * The easiest way to do this is to create a subclass of {@link AbstractCommand}
 * and implement the abstract methods.
 * 
 * To finally enable this command, add this to {@link CommandFactory} in the
 * constructor like below for this sample class.
 * 
 * {@code
 * 
 * private CommandFactory() { super(); put(new ExportConfigurationsCmd());
 * put(new ImportTypeSystemCmd()); put(new DeliverTypeSystemCmd()); put(new
 * SampleCommand()); } }
 * 
 * to finalize the integration.
 * 
 */
public class SampleCommandCmd extends AbstractCommand implements ICommand {

	public static final Logger logger = LoggerFactory.getLogger(SampleCommandCmd.class);

	/**
	 * Constructor, set the command name which will be used as option value for
	 * the command option. The name is used in the UIs and the option parser.
	 */
	public SampleCommandCmd() {
		super(SupportToolsFrameworkConstants.CMD_SAMPLE);
	}

	/**
	 * Method to add the options this command requires.
	 */
	@Override
	public Options addCommandOptions(Options options) {
		// Add Options required for the command
		//
		// Example code
		options.addOption(SupportToolsFrameworkConstants.PARAMETER_SAMPLE_OPTION, true,
				SupportToolsFrameworkConstants.PARAMETER_SAMPLE_OPTION_DESCRIPTION);
		options.addOption(SupportToolsFrameworkConstants.PARAMETER_SAMPLE_OPTION_OPT, true,
				SupportToolsFrameworkConstants.PARAMETER_SAMPLE_OPTION_OPT_DESCRIPTION);
		return options;
	}

	/**
	 * Method to check if the required options/parameters required to perform
	 * the command are available.
	 */
	@Override
	public boolean checkParameters(CommandLine cmd) {
		// Check for required options
		boolean isValid = true;

		if (!cmd.hasOption(SupportToolsFrameworkConstants.PARAMETER_SAMPLE_OPTION)) {
			isValid = false;
		}
		return isValid;
	}

	/**
	 * Method to print the syntax in case of missing options.
	 */
	@Override
	public void printSyntax() {
		// Print syntax hint for the command
		//
		// Example code
		logger.info("{}", getCommandName());
		logger.info("\n\tA sample command that can be used as template for adding custom commands.");
		logger.info("\n\tSyntax : -{} {} -{} {} [ -{} {} ]", SupportToolsFrameworkConstants.PARAMETER_COMMAND,
				getCommandName(), SupportToolsFrameworkConstants.PARAMETER_SAMPLE_OPTION,
				SupportToolsFrameworkConstants.PARAMETER_SAMPLE_OPTION_PROTOTYPE,
				SupportToolsFrameworkConstants.PARAMETER_SAMPLE_OPTION_OPT,
				SupportToolsFrameworkConstants.PARAMETER_SAMPLE_OPTION_OPT_PROTOTYPE);
		logger.info("\tExample: -{} {} -{} {}", SupportToolsFrameworkConstants.PARAMETER_COMMAND, getCommandName(),
				SupportToolsFrameworkConstants.PARAMETER_SAMPLE_OPTION,
				SupportToolsFrameworkConstants.PARAMETER_SAMPLE_OPTION_EXAMPLE);
		logger.info("\tOptional parameter: -{} {}", SupportToolsFrameworkConstants.PARAMETER_SAMPLE_OPTION_OPT,
				SupportToolsFrameworkConstants.PARAMETER_SAMPLE_OPTION_OPT_PROTOTYPE);
		logger.info("\tExample optional parameter: -{} {}", SupportToolsFrameworkConstants.PARAMETER_SAMPLE_OPTION_OPT,
				SupportToolsFrameworkConstants.PARAMETER_SAMPLE_OPTION_OPT_EXAMPLE);
	}

	/**
	 * The main method that executes the behavior of this command.
	 */
	@SuppressWarnings("unused")
	@Override
	public boolean execute() {
		logger.info("Executing Command {}", this.getCommandName());
		boolean result = false;
		// Execute the code
		// Get all the option values
		String mandatoryOption = getCmd().getOptionValue(SupportToolsFrameworkConstants.PARAMETER_SAMPLE_OPTION);
		String optionalOption = getCmd().getOptionValue(SupportToolsFrameworkConstants.PARAMETER_SAMPLE_OPTION_OPT);

		/**
		 * TODO: Your code goes here
		 * 
		 */
		result = true;

		return result;
	}
}
