Lorem ipsum dolor sit amet, consectetur adipiscing elit, 
sed do eiusmod tempor incididunt ut labore et dolore magna 
aliqua. Ut enim ad minim veniam, quis nostrud exercitation 
ullamco laboris nisi ut aliquip ex ea commodo consequat. 
Duis aute irure dolor in reprehenderit in voluptate velit 
esse cillum dolore eu fugiat nulla pariatur. Excepteur 
sint occaecat cupidatat non proident, sunt in culpa qui 
officia deserunt mollit anim id est laborum. Lorem ipsum 
dolor sit amet, consectetur adipiscing elit, sed do 
eiusmod tempor incididunt ut labore et dolore magna 
aliqua. Ut enim ad minim veniam, quis nostrud exercitation 
ullamco laboris nisi ut aliquip ex ea commodo consequat. 
Duis aute irure dolor in reprehenderit in voluptate velit 
esse cillum dolore eu fugiat nulla pariatur. Excepteur 
sint occaecat cupidatat non proident, sunt in culpa qui 
officia deserunt mollit anim id est laborum. Lorem ipsum 
dolor sit amet, consectetur adipiscing elit, sed do 
eiusmod tempor incididunt ut labore et dolore magna 
aliqua. Ut enim ad minim veniam, quis nostrud exercitation 
ullamco laboris nisi ut aliquip ex ea commodo consequat. 
Duis aute irure dolor in reprehenderit in voluptate velit 
esse cillum dolore eu fugiat nulla pariatur. Excepteur 
sint occaecat cupidatat non proident, sunt in culpa qui 
officia deserunt mollit anim id est laborum.
package com.ibm.js.team.supporttools.scm.commands;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileNotFoundException;
import java.io.FileOutputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStream;
import java.io.InputStreamReader;
import java.io.Reader;
import java.io.UnsupportedEncodingException;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Iterator;
import java.util.List;
import java.util.Map;
import java.util.Random;
import java.util.Set;
import java.util.zip.ZipEntry;
import java.util.zip.ZipOutputStream;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.Options;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.ibm.js.team.supporttools.framework.SupportToolsFrameworkConstants;
import com.ibm.js.team.supporttools.framework.framework.AbstractCommand;
import com.ibm.js.team.supporttools.framework.framework.ICommand;
import com.ibm.js.team.supporttools.framework.util.FileUtil;
import com.ibm.js.team.supporttools.scm.ScmSupportToolsConstants;
import com.ibm.js.team.supporttools.scm.utils.ComponentUtil;
import com.ibm.team.filesystem.client.FileSystemCore;
import com.ibm.team.filesystem.client.IFileContentManager;
import com.ibm.team.filesystem.common.FileLineDelimiter;
import com.ibm.team.filesystem.common.IFileContent;
import com.ibm.team.filesystem.common.IFileItem;
import com.ibm.team.repository.client.ITeamRepository;
import com.ibm.team.repository.client.TeamPlatform;
import com.ibm.team.repository.common.TeamRepositoryException;
import com.ibm.team.repository.common.UUID;
import com.ibm.team.repository.common.json.JSONArray;
import com.ibm.team.repository.common.json.JSONObject;
import com.ibm.team.scm.client.IConfiguration;
import com.ibm.team.scm.client.IWorkspaceConnection;
import com.ibm.team.scm.common.IComponent;
import com.ibm.team.scm.common.IComponentHandle;
import com.ibm.team.scm.common.IComponentHierarchyResult;
import com.ibm.team.scm.common.IFolder;
import com.ibm.team.scm.common.IFolderHandle;
import com.ibm.team.scm.common.IVersionable;
import com.ibm.team.scm.common.IVersionableHandle;
import com.ibm.team.scm.common.IWorkspaceHandle;
import com.ibm.team.scm.common.dto.IWorkspaceSearchCriteria;
public class ExportRepositoryWorkspace extends AbstractCommand implements ICommand {
	private static final String CODE_SAMPLE_INPUT_FILE_NAME = "CodeSampleInput.txt";
	public static final Logger logger = LoggerFactory.getLogger(ExportRepositoryWorkspace.class);
	public boolean fPreserve = false;
	private Object fConfidentialityMode = ScmSupportToolsConstants.DEFAULT_STORAGE_MODE_RANDOMIZE;
	private File fOutputFolder = null;
	private int fProgress = 0;
	private ArrayList<String> fSampleLines = null;
	private int fNumberSamples = 0;
	/**
	 * Constructor, set the command name which will be used as option value for the
	 * command option. The name is used in the UIs and the option parser.
	 */
	public ExportRepositoryWorkspace() {
		super(ScmSupportToolsConstants.CMD_EXPORTWORKSPACE);
	}
	/**
	 * Method to add the options this command requires.
	 */
	@Override
	public Options addCommandOptions(Options options) {
		options.addOption(SupportToolsFrameworkConstants.PARAMETER_URL, true,
				SupportToolsFrameworkConstants.PARAMETER_URL_DESCRIPTION);
		options.addOption(SupportToolsFrameworkConstants.PARAMETER_USER, true,
				SupportToolsFrameworkConstants.PARAMETER_USER_ID_DESCRIPTION);
		options.addOption(SupportToolsFrameworkConstants.PARAMETER_PASSWORD, true,
				SupportToolsFrameworkConstants.PARAMETER_PASSWORD_DESCRIPTION);
		options.addOption(ScmSupportToolsConstants.PARAMETER_WORKSPACE_NAME_OR_ID, true,
				ScmSupportToolsConstants.PARAMETER_WORKSPACE_DESCRIPTION);
		options.addOption(ScmSupportToolsConstants.PARAMETER_OUTPUTFOLDER, true,
				ScmSupportToolsConstants.PARAMETER_OUTPUTFOLDER_DESCRIPTION);
		return options;
	}
	/**
	 * Method to check if the required options/parameters required to perform the
	 * command are available.
	 */
	@Override
	public boolean checkParameters(CommandLine cmd) {
		// Check for required options
		boolean isValid = true;

		if (!(cmd.hasOption(SupportToolsFrameworkConstants.PARAMETER_URL)
				&& cmd.hasOption(SupportToolsFrameworkConstants.PARAMETER_USER)
				&& cmd.hasOption(SupportToolsFrameworkConstants.PARAMETER_PASSWORD)
				&& cmd.hasOption(ScmSupportToolsConstants.PARAMETER_WORKSPACE_NAME_OR_ID)
				&& cmd.hasOption(ScmSupportToolsConstants.PARAMETER_OUTPUTFOLDER))) {
			isValid = false;
		}
		return isValid;
	}
	/**
	 * Method to print the syntax in case of missing options.
	 */
	@Override
	public void printSyntax() {
		logger.info("{}", getCommandName());
		logger.info(
				"\n\tExports the contents of a repository workspace into a set of zip files. Exports the repository workspace component hierarchy structure into a JSON file.");
		logger.info("\n\tSyntax : -{} {} -{} {} -{} {} -{} {} -{} {} -{} {}",
				SupportToolsFrameworkConstants.PARAMETER_COMMAND, getCommandName(),
				SupportToolsFrameworkConstants.PARAMETER_URL, SupportToolsFrameworkConstants.PARAMETER_URL_PROTOTYPE,
				SupportToolsFrameworkConstants.PARAMETER_USER, SupportToolsFrameworkConstants.PARAMETER_USER_PROTOTYPE,
				SupportToolsFrameworkConstants.PARAMETER_PASSWORD,
				SupportToolsFrameworkConstants.PARAMETER_PASSWORD_PROTOTYPE,
				ScmSupportToolsConstants.PARAMETER_WORKSPACE_NAME_OR_ID,
				ScmSupportToolsConstants.PARAMETER_WORKSPACE_PROTOTYPE, ScmSupportToolsConstants.PARAMETER_OUTPUTFOLDER,
				ScmSupportToolsConstants.PARAMETER_OUTPUTFOLDER_PROTOTYPE);
		logger.info("\tExample: -{} {} -{} {} -{} {} -{} {} -{} {} -{} {}", SupportToolsFrameworkConstants.PARAMETER_COMMAND,
				getCommandName(), SupportToolsFrameworkConstants.PARAMETER_URL,
				SupportToolsFrameworkConstants.PARAMETER_URL_EXAMPLE, SupportToolsFrameworkConstants.PARAMETER_USER,
				SupportToolsFrameworkConstants.PARAMETER_USER_ID_EXAMPLE,
				SupportToolsFrameworkConstants.PARAMETER_PASSWORD,
				SupportToolsFrameworkConstants.PARAMETER_PASSWORD_EXAMPLE,
				ScmSupportToolsConstants.PARAMETER_WORKSPACE_NAME_OR_ID,
				ScmSupportToolsConstants.PARAMETER_WORKSPACE_EXAMPLE, ScmSupportToolsConstants.PARAMETER_OUTPUTFOLDER,
				ScmSupportToolsConstants.PARAMETER_OUTPUTFOLDER_EXAMPLE
	/**
	 * The main method that executes the behavior of this command.
	 */
	@SuppressWarnings("unused")
	@Override
	public boolean execute() {
		logger.info("Executing Command {}", this.getCommandName());
		boolean result = false;
		// Execute the code
		// Get all the option values
		String repositoryURI = getCmd().getOptionValue(SupportToolsFrameworkConstants.PARAMETER_URL);
		final String userId = getCmd().getOptionValue(SupportToolsFrameworkConstants.PARAMETER_USER);
		final String userPassword = getCmd().getOptionValue(SupportToolsFrameworkConstants.PARAMETER_PASSWORD);
		String scmWorkspace = getCmd().getOptionValue(ScmSupportToolsConstants.PARAMETER_WORKSPACE_NAME_OR_ID);
		String outputFolderPath = getCmd().getOptionValue(ScmSupportToolsConstants.PARAMETER_OUTPUTFOLDER);

		TeamPlatform.startup();
		try {
			IProgressMonitor monitor = new NullProgressMonitor();
			ITeamRepository teamRepository = TeamPlatform.getTeamRepositoryService().getTeamRepository(repositoryURI);
			teamRepository.registerLoginHandler(new ITeamRepository.ILoginHandler() {
				public ILoginInfo challenge(ITeamRepository repository) {
					return new ILoginInfo() {
						public String getUserId() {
							return userId;
						}

						public String getPassword() {
							return userPassword;
						}
					};
				}
			});
			teamRepository.login(monitor);
			File outputfolder = new File(outputFolderPath);
			if (!outputfolder.exists()) {
				FileUtil.createFolderWithParents(outputfolder);
				if (!outputfolder.exists()) {
					logger.error("Error: Outputfolder '{}' could not be created.", outputFolderPath);
					return result;
				}
			}
			if (!outputfolder.isDirectory()) {
				logger.error("Error: '{}' is not a directory.", outputFolderPath);
				return result;
			}
			fOutputFolder = outputfolder;
			result = exportWorkspace(teamRepository, scmWorkspace, monitor);
		} catch (TeamRepositoryException e) {
			logger.error("TeamRepositoryException: {}", e.getMessage());
			// e.printStackTrace();
		} catch (IOException e) {
			logger.error("IOException: {}", e.getMessage());
			// e.printStackTrace();
		} finally {
			TeamPlatform.shutdown();
		}
		return result;
	}
	/**
	 * @param teamRepository
	 * @param outputfolder
	 * @param scmConnection
	 * @param monitor
	 * @return
	 * @throws TeamRepositoryException
	 * @throws IOException
	 */
	private boolean exportWorkspace(ITeamRepository teamRepository, String scmConnection, IProgressMonitor monitor)
			throws TeamRepositoryException, IOException {
		boolean result = false;
		logger.info("Find and open WorkspaceConnection '{}'...", scmConnection);
		List<IWorkspaceHandle> connections = ComponentUtil.findWorkspacesByName(teamRepository, scmConnection,
				IWorkspaceSearchCriteria.WORKSPACES, monitor);
		if (connections.size() < 1) {
			logger.error("Error: WorkspaceConnection '{}' not found.", scmConnection);
			return result;
		}
		if (connections.size() > 1) {
			logger.error("Error: WorkspaceConnection '{}' not unique.", scmConnection);
			return result;
		}
		List<? extends IWorkspaceConnection> connection = ComponentUtil.getWorkspaceConnections(teamRepository,
				connections, monitor);
		IWorkspaceConnection workspace = connection.get(0);
		logger.info("Anylyze and store component hierarchy for '{}'...", scmConnection);
		IComponentHierarchyResult hierarchy = connection.get(0)
				.getComponentHierarchy(new ArrayList<IComponentHandle>());
		writeHierarchy(teamRepository, hierarchy, monitor);
		logger.info("Package and Ramdomize Components...");
		Collection<IComponentHandle> components = hierarchy.getFlattenedElementsMap().values();
		result = packageComponentHandles(teamRepository, fOutputFolder, workspace, components, monitor);
		return result;
	}
private void writeHierarchy(ITeamRepository teamRepository, IComponentHierarchyResult hierarchy,
			IProgressMonitor monitor) throws TeamRepositoryException, UnsupportedEncodingException, IOException {
		Map<UUID, Collection<IComponentHandle>> par2Child = hierarchy.getParentToChildrenMap();
		Map<UUID, IComponentHandle> flat = hierarchy.getFlattenedElementsMap();
		writeChildMap(teamRepository, flat, par2Child, monitor);
	}
	private void writeChildMap(ITeamRepository teamRepository, Map<UUID, IComponentHandle> flat,
			Map<UUID, Collection<IComponentHandle>> par2Child, IProgressMonitor monitor)
			throws TeamRepositoryException, UnsupportedEncodingException, IOException {
		File jsonFile = new File(fOutputFolder, ScmSupportToolsConstants.HIERARCHY_JSON_FILE);
		logger.info("Persist component hierarchy in '{}'...", jsonFile.getAbsolutePath());
		JSONArray jsonhierarchy = new JSONArray();
		Set<UUID> parents = par2Child.keySet();
		for (Iterator<UUID> iterator = parents.iterator(); iterator.hasNext();) {
			UUID parent = (UUID) iterator.next();
			IComponent parentComp = ComponentUtil.resolveComponent(teamRepository, flat.get(parent), monitor);
			JSONObject component = new JSONObject();
			logger.info("\tComponent... '{}'", parentComp.getName());
			component.put(ScmSupportToolsConstants.COMPONENT_NAME, parentComp.getName());
			component.put(ScmSupportToolsConstants.COMPONENT_UUID, parentComp.getItemId().getUuidValue());
			JSONArray jsonChildren = new JSONArray();
			Collection<IComponentHandle> children = par2Child.get(parent);
			for (Iterator<IComponentHandle> childIter = children.iterator(); childIter.hasNext();) {
				IComponentHandle handle = (IComponentHandle) childIter.next();
				IComponent child = ComponentUtil.resolveComponent(teamRepository, handle, monitor);
				JSONObject childComponent = new JSONObject();
				childComponent.put(ScmSupportToolsConstants.COMPONENT_NAME, child.getName());
				childComponent.put(ScmSupportToolsConstants.COMPONENT_UUID, child.getItemId().getUuidValue());
				jsonChildren.add(childComponent);
				component.put(ScmSupportToolsConstants.COMPONENT_CHILDREN, jsonChildren);
			}
			jsonhierarchy.add(component);
		}
		jsonhierarchy.serialize(new FileWriter(jsonFile), true);
	}

	/**
	 * @param teamRepository
	 * @param outputfolder
	 * @param connection
	 * @param components
	 * @param monitor
	 * @return
	 * @throws IOException
	 * @throws TeamRepositoryException
	 */
	private boolean packageComponents(ITeamRepository teamRepository, File outputfolder,
			IWorkspaceConnection connection, List<IComponent> components, IProgressMonitor monitor)
			throws IOException, TeamRepositoryException {
		boolean result = true;
		initializeSampleLines();

		int currentComponent = 0;
		int noOfComponents = components.size();
		for (IComponent component : components) {
			logger.info("\tPacking {} of {} component'{}' UUID '{}'", currentComponent++, noOfComponents,
					component.getName(), component.getItemId().getUuidValue());
			result &= packageComponent(teamRepository, connection, component, monitor);
		}
		return result;
	}
	private void initializeSampleLines() throws UnsupportedEncodingException, FileNotFoundException, IOException {
		BufferedReader reader = new BufferedReader(new InputStreamReader(new FileInputStream(CODE_SAMPLE_INPUT_FILE_NAME), IFileContent.ENCODING_UTF_8));
		fSampleLines = new ArrayList<String>(200);
		String line;
		do {
			line = reader.readLine();
			if (line!=null) {
				fSampleLines.add(line);
			}
		} while (line!=null);
		reader.close();
		fNumberSamples = fSampleLines.size();
	}
//	private boolean packageComponentHandles(ITeamRepository teamRepository, File outputfolder,
//			List<? extends IWorkspaceConnection> connection, Collection<IComponentHandle> components2, IProgressMonitor monitor)
//			throws IOException, TeamRepositoryException {
//		List<IComponent> components = resolveComponents(teamRepository, components2, monitor);
//
//		return packageComponents(teamRepository, outputfolder, connection, components, monitor);
//	}
	private boolean packageComponentHandles(ITeamRepository teamRepository, File outputFolder,
			IWorkspaceConnection connection, Collection<IComponentHandle> componentHandles, IProgressMonitor monitor)
			throws TeamRepositoryException, IOException {
		List<IComponent> components = ComponentUtil.resolveComponents(teamRepository,
				new ArrayList<IComponentHandle>(componentHandles), monitor);
		return packageComponents(teamRepository, outputFolder, connection, components, monitor);
	}
	/**
	 * @param teamRepository
	 * @param outputfolder
	 * @param connection
	 * @param component
	 * @param monitor
	 * @return
	 * @throws TeamRepositoryException
	 * @throws IOException
	 */
	private boolean packageComponent(ITeamRepository teamRepository, IWorkspaceConnection connection,
			IComponent component, IProgressMonitor monitor) throws TeamRepositoryException, IOException {
		boolean result = false;
		// Start walking the workspace contents
		IFileContentManager contentManager = FileSystemCore.getContentManager(teamRepository);
		File base = fOutputFolder;
		FileOutputStream out = new FileOutputStream(new File(base, component.getName().trim() + ".zip"));
		try {
			ZipOutputStream zos = new ZipOutputStream(out);
			IConfiguration compConfig = connection.configuration(component);
			// Fetch the items at the root of each component. We do this to initialize our
			// queue of stuff to download.
			@SuppressWarnings("unchecked")
			Map<String, IVersionableHandle> handles = compConfig.childEntriesForRoot(monitor);
			@SuppressWarnings("unchecked")
			List<IVersionable> items = compConfig
					.fetchCompleteItems(new ArrayList<IVersionableHandle>(handles.values()), monitor);
			loadDirectory(contentManager, compConfig, zos, "", items, monitor);
			zos.close();
			result = true;
		} finally {
			out.close();
			System.out.println("");
		}
		return result;
	}
	/**
	 * @param contentManager
	 * @param compConfig
	 * @param zos
	 * @param path
	 * @param items
	 * @param monitor
	 * @throws IOException
	 * @throws TeamRepositoryException
	 */
	private void loadDirectory(IFileContentManager contentManager, IConfiguration compConfig, ZipOutputStream zos,
			String path, List<IVersionable> items, IProgressMonitor monitor)
			throws IOException, TeamRepositoryException {
		for (IVersionable v : items) {
			if (v instanceof IFolder) {
				// Write the directory
				String dirPath = path + v.getName() + "/";
				zos.putNextEntry(new ZipEntry(dirPath));
				@SuppressWarnings("unchecked")
				Map<String, IVersionableHandle> children = compConfig.childEntries((IFolderHandle) v, monitor);
				@SuppressWarnings("unchecked")
				List<IVersionable> completeChildren = compConfig
						.fetchCompleteItems(new ArrayList<IVersionableHandle>(children.values()), monitor);
				loadDirectory(contentManager, compConfig, zos, dirPath, completeChildren, monitor);
			} else if (v instanceof IFileItem) {
				// Get the file contents and write them into the directory
				IFileItem file = (IFileItem) v;
				zos.putNextEntry(new ZipEntry(path + v.getName()));
				InputStream in = generateContent(file, contentManager, monitor);
				byte[] arr = new byte[1024];
				int w;
				while (-1 != (w = in.read(arr))) {
					byte[] orr = process(arr);
					zos.write(orr, 0, w);
				}
				zos.closeEntry();
			}
			showProgress();
		}
	}
	private InputStream generateContent(IFileItem file, IFileContentManager contentManager, IProgressMonitor monitor) throws TeamRepositoryException, IOException {
		FileLineDelimiter lineDelimiter = FileLineDelimiter.LINE_DELIMITER_NONE;
		String encoding = null;
		IFileContent filecontent = file.getContent();
		if (filecontent != null) {
			encoding = filecontent.getCharacterEncoding();
			lineDelimiter = filecontent.getLineDelimiter();
		}
		String contentType = file.getContentType();
		InputStream in = contentManager.retrieveContentStream(file, file.getContent(), monitor);
		if(FileLineDelimiter.LINE_DELIMITER_NONE.equals(lineDelimiter)) {
		} else {
			BufferedReader reader = new BufferedReader(new InputStreamReader(in));
            String line = obfuscate (reader.readLine());
		}
		logger.info(" Fileinfo: '{}' Enc: '{}' Delim: '{}' Content: '{}'", file.getName(), encoding, lineDelimiter, contentType );
		return in;
	}
	private String obfuscate(String readLine) {
		// TODO Auto-generated method stub
		return null;
	}
	private byte[] process(byte[] arr) {
		if (fPreserve) {
			return arr;
		}
		if (ScmSupportToolsConstants.STORAGE_MODE_OBFUSCATE.equals(fConfidentialityMode)) {
			return obfuscate(arr);
		}
		return randomize(arr);
	}
	private byte[] randomize(byte[] arr) {
		byte[] orr = new byte[arr.length];
		new Random().nextBytes(orr);
		return orr;
	}
	private byte[] obfuscate(byte[] arr) {
		byte[] orr = new byte[arr.length];
		System.arraycopy(ScmSupportToolsConstants.LOREM_IPSUM.getBytes(), 0, orr, 0, arr.length);
		return orr;
	}
//	private void writeRoots(ITeamRepository teamRepository, Collection<IComponentHierarchyNode> roots,
//			IProgressMonitor monitor) throws TeamRepositoryException, UnsupportedEncodingException, IOException {
//		logger.info("Roots...");
//		FileOutputStream out = new FileOutputStream(new File(fOutputFolder, "rootcomponents.txt"));
//		try {
//			for (IComponentHierarchyNode node : roots) {
//				IComponent comp = ComponentUtil.resolveComponent(teamRepository, node.getComponentHandle(), monitor);
//				logger.info("Root '{}' UUID '{}'", comp.getName(), comp.getItemId().getUuidValue());
//				String componentInfo = comp.getName() + " " + comp.getItemId().getUuidValue() + "\n";
//				out.write(componentInfo.getBytes("UTF-8"));
//			}
//			out.flush();
//		} finally {
//			out.close();
//		}
//	}
//
//	private void writeComponents(List<IComponent> components) throws UnsupportedEncodingException, IOException {
//		logger.info("Components...");
//		FileOutputStream out = new FileOutputStream(new File(fOutputFolder, "components.txt"));
//		try {
//			for (IComponent comp : components) {
//				logger.info("'{}' UUID '{}'", comp.getName(), comp.getItemId().getUuidValue());
//				String componentInfo = comp.getName() + " " + comp.getItemId().getUuidValue() + "\n";
//				out.write(componentInfo.getBytes("UTF-8"));
//			}
//			out.flush();
//		} finally {
//			out.close();
//		}
//	}
	private void showProgress() {
		fProgress++;
		if (fProgress % 10 == 9) {
			System.out.print(".");
		}
	}
}
package com.ibm.js.team.supporttools.scm.commands;
import java.io.BufferedReader;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.IOException;
import java.io.InputStreamReader;
import java.io.Reader;
import java.net.URI;
import java.util.ArrayList;
import java.util.Collection;
import java.util.Collections;
import java.util.HashMap;
import java.util.List;
import java.util.Set;
import org.apache.commons.cli.CommandLine;
import org.apache.commons.cli.Options;
import org.eclipse.core.runtime.IProgressMonitor;
import org.eclipse.core.runtime.NullProgressMonitor;
import org.slf4j.Logger;
import org.slf4j.LoggerFactory;
import com.ibm.js.team.supporttools.framework.SupportToolsFrameworkConstants;
import com.ibm.js.team.supporttools.framework.framework.AbstractCommand;
import com.ibm.js.team.supporttools.framework.framework.ICommand;
import com.ibm.js.team.supporttools.scm.ScmSupportToolsConstants;
import com.ibm.js.team.supporttools.scm.utils.ArchiveToSCMExtractor;
import com.ibm.js.team.supporttools.scm.utils.ComponentUtil;
import com.ibm.team.filesystem.common.IFileContent;
import com.ibm.team.process.client.IProcessClientService;
import com.ibm.team.process.client.IProcessItemService;
import com.ibm.team.process.common.IProcessArea;
import com.ibm.team.process.common.IProjectArea;
import com.ibm.team.repository.client.ITeamRepository;
import com.ibm.team.repository.client.TeamPlatform;
import com.ibm.team.repository.common.IAuditableHandle;
import com.ibm.team.repository.common.TeamRepositoryException;
import com.ibm.team.repository.common.UUID;
import com.ibm.team.repository.common.json.JSONArray;
import com.ibm.team.repository.common.json.JSONObject;
import com.ibm.team.scm.client.IWorkspaceConnection;
import com.ibm.team.scm.client.IWorkspaceManager;
import com.ibm.team.scm.client.SCMPlatform;
import com.ibm.team.scm.common.IChangeSetHandle;
import com.ibm.team.scm.common.IComponentHandle;
import com.ibm.team.scm.common.IWorkspaceHandle;
import com.ibm.team.scm.common.dto.IComponentSearchCriteria;
import com.ibm.team.scm.common.dto.IWorkspaceSearchCriteria;
public class ImportRepositoryWorkspace extends AbstractCommand implements ICommand {
	public static final Logger logger = LoggerFactory.getLogger(ImportRepositoryWorkspace.class);
	private File fInputFolder = null;
	private IAuditableHandle fArea;
	private String fNamePrefixr = null;
	private int fProgress = 0;
	private boolean reuseExistingWorkspace = false;
	/**
	 * Constructor, set the command name which will be used as option value for the
	 * command option. The name is used in the UIs and the option parser.
	 */
	public ImportRepositoryWorkspace() {
		super(ScmSupportToolsConstants.CMD_IMPORTWORKSPACE);
	}
	/**
	 * Method to add the options this command requires.
	 */
	@Override
	public Options addCommandOptions(Options options) {
		options.addOption(SupportToolsFrameworkConstants.PARAMETER_URL, true,
				SupportToolsFrameworkConstants.PARAMETER_URL_DESCRIPTION);
		options.addOption(SupportToolsFrameworkConstants.PARAMETER_USER, true,
				SupportToolsFrameworkConstants.PARAMETER_USER_ID_DESCRIPTION);
		options.addOption(SupportToolsFrameworkConstants.PARAMETER_PASSWORD, true,
				SupportToolsFrameworkConstants.PARAMETER_PASSWORD_DESCRIPTION);
		options.addOption(SupportToolsFrameworkConstants.PARAMETER_PROJECT_AREA, true,
				SupportToolsFrameworkConstants.PARAMETER_PROJECT_AREA_DESCRIPTION);
		options.addOption(ScmSupportToolsConstants.PARAMETER_WORKSPACE_NAME_OR_ID, true,
				ScmSupportToolsConstants.PARAMETER_WORKSPACE_DESCRIPTION);
		options.addOption(ScmSupportToolsConstants.PARAMETER_INPUTFOLDER, true,
				ScmSupportToolsConstants.PARAMETER_INPUTFOLDER_DESCRIPTION);
		options.addOption(ScmSupportToolsConstants.PARAMETER_COMPONENT_NAME_MODIFIER, true,
				ScmSupportToolsConstants.PARAMETER_COMPONENT_NAME_MODIFIER_DESCRIPTION);
		options.addOption(ScmSupportToolsConstants.PARAMETER_REUSE_EXISTING_WORKSPACE_FLAG, false,
				ScmSupportToolsConstants.PARAMETER_REUSE_EXISTING_WORKSPACE_FLAG_DESCRIPTION);
		return options;
	}
	/**
	 * Method to check if the required options/parameters required to perform the
	 * command are available.
	 */
	@Override
	public boolean checkParameters(CommandLine cmd) {
		// Check for required options
		boolean isValid = true;

		if (!(cmd.hasOption(SupportToolsFrameworkConstants.PARAMETER_URL)
				&& cmd.hasOption(SupportToolsFrameworkConstants.PARAMETER_USER)
				&& cmd.hasOption(SupportToolsFrameworkConstants.PARAMETER_PASSWORD)
				&& cmd.hasOption(SupportToolsFrameworkConstants.PARAMETER_PROJECT_AREA)
				&& cmd.hasOption(ScmSupportToolsConstants.PARAMETER_WORKSPACE_NAME_OR_ID)
				&& cmd.hasOption(ScmSupportToolsConstants.PARAMETER_INPUTFOLDER))) {
			isValid = false;
		}
		return isValid;
	}
	/**
	 * Method to print the syntax in case of missing options.
	 */
	@Override
	public void printSyntax() {
		logger.info("{}", getCommandName());
		logger.info(
				"\n\tCreates a repository workspace and its components from a JSON file describing the workspace component hierarchy structure. Imports the contents of each component from a into a set of zip files. ");
		logger.info("\n\tSyntax : -{} {} -{} {} -{} {} -{} {} -{} {} -{} {} -{} {}",
				SupportToolsFrameworkConstants.PARAMETER_COMMAND, getCommandName(),
				SupportToolsFrameworkConstants.PARAMETER_URL, SupportToolsFrameworkConstants.PARAMETER_URL_PROTOTYPE,
				SupportToolsFrameworkConstants.PARAMETER_USER, SupportToolsFrameworkConstants.PARAMETER_USER_PROTOTYPE,
				SupportToolsFrameworkConstants.PARAMETER_PASSWORD,
				SupportToolsFrameworkConstants.PARAMETER_PASSWORD_PROTOTYPE,
				SupportToolsFrameworkConstants.PARAMETER_PROJECT_AREA,
				SupportToolsFrameworkConstants.PARAMETER_PROJECT_AREA_PROTOTYPE,
				ScmSupportToolsConstants.PARAMETER_WORKSPACE_NAME_OR_ID,
				ScmSupportToolsConstants.PARAMETER_WORKSPACE_PROTOTYPE, ScmSupportToolsConstants.PARAMETER_INPUTFOLDER,
				ScmSupportToolsConstants.PARAMETER_INPUTFOLDER_PROTOTYPE);
		logger.info("\tExample: -{} {} -{} {} -{} {} -{} {} -{} {} -{} {} -{} {}", SupportToolsFrameworkConstants.PARAMETER_COMMAND,
				getCommandName(), SupportToolsFrameworkConstants.PARAMETER_URL,
				SupportToolsFrameworkConstants.PARAMETER_URL_EXAMPLE, SupportToolsFrameworkConstants.PARAMETER_USER,
				SupportToolsFrameworkConstants.PARAMETER_USER_ID_EXAMPLE,
				SupportToolsFrameworkConstants.PARAMETER_PASSWORD,
				SupportToolsFrameworkConstants.PARAMETER_PASSWORD_EXAMPLE,
				SupportToolsFrameworkConstants.PARAMETER_PROJECT_AREA,
				SupportToolsFrameworkConstants.PARAMETER_PROJECT_AREA_EXAMPLE,
				ScmSupportToolsConstants.PARAMETER_WORKSPACE_NAME_OR_ID,
				ScmSupportToolsConstants.PARAMETER_WORKSPACE_EXAMPLE, ScmSupportToolsConstants.PARAMETER_INPUTFOLDER,
				ScmSupportToolsConstants.PARAMETER_INPUTFOLDER_EXAMPLE);
	logger.info("\tOptional parameter: -{} {} -{}", ScmSupportToolsConstants.PARAMETER_COMPONENT_NAME_MODIFIER,
				ScmSupportToolsConstants.PARAMETER_COMPONENT_NAME_MODIFIER_PROTOTYPE,
				ScmSupportToolsConstants.PARAMETER_REUSE_EXISTING_WORKSPACE_FLAG);
		logger.info("\tExample optional parameter: -{} {} -{}",
				ScmSupportToolsConstants.PARAMETER_COMPONENT_NAME_MODIFIER,
				ScmSupportToolsConstants.PARAMETER_COMPONENT_NAME_MODIFIER_EXAMPLE,
				ScmSupportToolsConstants.PARAMETER_REUSE_EXISTING_WORKSPACE_FLAG);
	}
	/**
	 * The main method that executes the behavior of this command.
	 */
	@Override
	public boolean execute() {
		logger.info("Executing Command {}", this.getCommandName());
		boolean result = false;
		// Execute the code
		// Get all the option values
		final String repositoryURI = getCmd().getOptionValue(SupportToolsFrameworkConstants.PARAMETER_URL);
		final String userId = getCmd().getOptionValue(SupportToolsFrameworkConstants.PARAMETER_USER);
		final String userPassword = getCmd().getOptionValue(SupportToolsFrameworkConstants.PARAMETER_PASSWORD);
		final String projectAreaName = getCmd().getOptionValue(SupportToolsFrameworkConstants.PARAMETER_PROJECT_AREA);
		final String scmWorkspace = getCmd().getOptionValue(ScmSupportToolsConstants.PARAMETER_WORKSPACE_NAME_OR_ID);
		final String inputFolderPath = getCmd().getOptionValue(ScmSupportToolsConstants.PARAMETER_INPUTFOLDER);
		final String componentNameModifier = getCmd()
				.getOptionValue(ScmSupportToolsConstants.PARAMETER_COMPONENT_NAME_MODIFIER);
		reuseExistingWorkspace = getCmd().hasOption(ScmSupportToolsConstants.PARAMETER_REUSE_EXISTING_WORKSPACE_FLAG);

		if (componentNameModifier != null) {
			logger.info("Using prefix '{}' on component names to force creation of new components.",
					componentNameModifier);
			setComponentNameModifier(componentNameModifier);
		}
		TeamPlatform.startup();
		try {
			IProgressMonitor monitor = new NullProgressMonitor();
			ITeamRepository teamRepository = TeamPlatform.getTeamRepositoryService().getTeamRepository(repositoryURI);
			teamRepository.registerLoginHandler(new ITeamRepository.ILoginHandler() {
				public ILoginInfo challenge(ITeamRepository repository) {
					return new ILoginInfo() {
						public String getUserId() {
							return userId;
						}

						public String getPassword() {
							return userPassword;
						}
					};
				}
			});
			teamRepository.login(monitor);
			File inputfolder = new File(inputFolderPath);
			if (!inputfolder.exists()) {
				logger.error("Error: Outputfolder '{}' does not exist.", inputFolderPath);
				return result;
			}
			if (!inputfolder.isDirectory()) {
				logger.error("Error: Outputfolder '{}' is not a directory.", inputFolderPath);
				return result;
			}
			fInputFolder = inputfolder;
			result = importWorkspace(teamRepository, projectAreaName, scmWorkspace, monitor);
		} catch (TeamRepositoryException e) {
			logger.error("TeamRepositoryException: {}", e.getMessage());
			// e.printStackTrace();
		} catch (IOException e) {
			logger.error("IOException: {}", e.getMessage());
			// e.printStackTrace();
		} catch (Exception e) {
			// TODO Auto-generated catch block
			e.printStackTrace();
		} finally {
			TeamPlatform.shutdown();
		}

		return result;
	}
	private boolean importWorkspace(ITeamRepository teamRepository, String projectAreaName, String scmConnection,
			IProgressMonitor monitor) throws Exception {

		// Find Or Create Workspace
		logger.info("Find or create repository workspace '{}'...", scmConnection);

		IWorkspaceConnection targetWorkspace = null;
		List<IWorkspaceHandle> connections = ComponentUtil.findWorkspacesByName(teamRepository, scmConnection,
				IWorkspaceSearchCriteria.WORKSPACES, monitor);
		if (connections.size() > 0) {
			if (!reuseExistingWorkspace) {
				logger.error("WorkspaceConnection '{}' already exists.", scmConnection);
				return false;
			}
			List<? extends IWorkspaceConnection> connection = ComponentUtil.getWorkspaceConnections(teamRepository,
					connections, monitor);
			targetWorkspace = connection.get(0);
		}
		if (targetWorkspace == null) {
			IWorkspaceManager wm = SCMPlatform.getWorkspaceManager(teamRepository);
			targetWorkspace = wm.createWorkspace(teamRepository.loggedInContributor(), scmConnection,
					"Testworkspace " + scmConnection, monitor);
		}
		// Find Project Area
		IProcessClientService processClient = (IProcessClientService) teamRepository
				.getClientLibrary(IProcessClientService.class);
		fArea = findProjectAreaByFQN(projectAreaName, processClient, monitor);
		// Get the required components
//		HashMap<String,UUID> sourceComponentMap = new HashMap<String,UUID>(3000);		
		HashMap<String, UUID> sourceComponentName2UUIDMap = new HashMap<String, UUID>(3000);
		HashMap<String, ArrayList<String>> sourcePar2ChildMap = new HashMap<String, ArrayList<String>>(3000);
		File jsonInputFile = new File(fInputFolder, ScmSupportToolsConstants.HIERARCHY_JSON_FILE);
		Reader reader = new BufferedReader(new InputStreamReader(new FileInputStream(jsonInputFile), IFileContent.ENCODING_UTF_8)); 
		logger.info("Reading component structure from file '{}'...", jsonInputFile.getAbsolutePath());
		JSONArray comps = JSONArray.parse(reader);
		for (Object comp : comps) {
			if (comp instanceof JSONObject) {
				String componentName = null;
				JSONObject jsonComp = (JSONObject) comp;
				Object oname = jsonComp.get(ScmSupportToolsConstants.COMPONENT_NAME);
				componentName = modifyNameForTests((String) oname);
				String ouuid = (String) jsonComp.get(ScmSupportToolsConstants.COMPONENT_UUID);
				sourceComponentName2UUIDMap.put(componentName, UUID.valueOf(ouuid));
				ArrayList<String> childrenList = new ArrayList<String>(20);
				Object ochildren = jsonComp.get(ScmSupportToolsConstants.COMPONENT_CHILDREN);
				if (null != ochildren && ochildren instanceof JSONArray) {
					JSONArray children = (JSONArray) ochildren;
					for (Object ochild : children) {
						if (ochild instanceof JSONObject) {
							JSONObject child = (JSONObject) ochild;
							String childname = (String) child.get(ScmSupportToolsConstants.COMPONENT_NAME);
							childrenList.add(modifyNameForTests(childname));
						}
					}
				}
				sourcePar2ChildMap.put(componentName, childrenList);
				logger.info("\tComponent -> '{}' done", componentName);
			}
		}
		logger.info("Find or create components...");
		IWorkspaceManager wm = SCMPlatform.getWorkspaceManager(teamRepository);
		JSONArray jsonComponentMap = new JSONArray();
		// Run 1 to get a map for the components needed. Find or create the components.
		HashMap<String, IComponentHandle> targetComponentMap = new HashMap<String, IComponentHandle>(
				sourcePar2ChildMap.size());
		Set<String> compKeys = sourcePar2ChildMap.keySet();
		for (String compName : compKeys) {
			logger.info("\tComponent '{}'", compName);
			IComponentHandle foundComponent = findComponentByName(wm, compName, monitor);
			if (foundComponent == null) {
				foundComponent = createComponent(teamRepository, monitor, wm, compName);
			}
			targetComponentMap.put(compName, foundComponent);
			JSONObject jsonComponent = new JSONObject();
			jsonComponent.put(ScmSupportToolsConstants.COMPONENT_NAME, compName);
			jsonComponent.put(ScmSupportToolsConstants.SOURCE_COMPONENT_UUID,
					sourceComponentName2UUIDMap.get(compName).getUuidValue());
			jsonComponent.put(ScmSupportToolsConstants.TARGET_COMPONENT_UUID,
					foundComponent.getItemId().getUuidValue());
			jsonComponentMap.add(jsonComponent);
		}
		File jsonComponentMappingFile = new File(fInputFolder, ScmSupportToolsConstants.COMPONENT_MAPPING_JSON_FILE);
		logger.info("Persist component source to target UUID mapping '{}'...",
				jsonComponentMappingFile.getAbsolutePath());
		jsonComponentMap.serialize(new FileWriter(jsonComponentMappingFile), true);

		logger.info("Strip workspace from components...");
		removeAllCompoentsFormWorkspaceConnection(targetWorkspace, monitor);
		logger.info("Add components to workspace...");
		addComponentsToWorkspaceConnection(targetWorkspace, targetComponentMap, monitor);
		// Run 2 to get the child mapping
		logger.info("Recreate subcomponent structure in workspace...");
		Set<String> compKeys2 = sourcePar2ChildMap.keySet();
		for (String compName : compKeys2) {
			logger.info("\tComponent '{}'", compName);
			IComponentHandle handle = targetComponentMap.get(compName);
			Collection<IComponentHandle> subcomponentsToAdd = new ArrayList<IComponentHandle>();
			ArrayList<String> children = sourcePar2ChildMap.get(compName);
			if (!children.isEmpty()) {
				for (String child : children) {
					IComponentHandle childHandle = targetComponentMap.get(child);
					subcomponentsToAdd.add(childHandle);
				}
				IChangeSetHandle subComponentChangeSet = targetWorkspace.createChangeSet(handle,
						"Subcomponents for " + compName, true, monitor);
				targetWorkspace.updateSubcomponentData(handle, subcomponentsToAdd, new ArrayList<IComponentHandle>(),
						subComponentChangeSet, monitor);
				targetWorkspace.closeChangeSets(Collections.singletonList(subComponentChangeSet), monitor);
			}
		}
		// Run 3 upload the source code
		logger.info("Import component data...");
		Set<String> compKeys3 = sourcePar2ChildMap.keySet();
		int currentComponent = 0;
		int noOfComponents = compKeys3.size();
		for (String compName : compKeys3) {
			logger.info("\t {} of {} Component '{}'", currentComponent++, noOfComponents, compName);
			IComponentHandle handle = targetComponentMap.get(compName);
			ArchiveToSCMExtractor scmExt = new ArchiveToSCMExtractor();
			File archiveFile = new File(fInputFolder, normalizeName(compName) + ".zip");
			if (!scmExt.extractFileToComponent(archiveFile.getAbsolutePath(), targetWorkspace, handle,
					"Source for Component " + compName, monitor)) {
				System.out.println();
				throw new Exception("Exception extracting " + compName);
			}
			System.out.println();
		}
		return true;
	}
	private IComponentHandle createComponent(ITeamRepository teamRepository, IProgressMonitor monitor,
			IWorkspaceManager wm, String compName) throws TeamRepositoryException {
		IComponentHandle component;
		// Create Component
		component = wm.createComponent(compName, teamRepository.loggedInContributor(), monitor);
		wm.setComponentOwner(component, fArea, monitor);
		return component;
	}
	private IComponentHandle findComponentByName(IWorkspaceManager wm, String compName, IProgressMonitor monitor)
			throws TeamRepositoryException {
		IComponentSearchCriteria criteria = IComponentSearchCriteria.FACTORY.newInstance();
		criteria.setExactName(compName);
		List<IComponentHandle> found = wm.findComponents(criteria, Integer.MAX_VALUE, monitor);
		if (found.size() > 1) {
			logger.error("Ambiguous Component Name '{}'", compName);
			throw new RuntimeException("Ambiguous Component Name '{" + compName + "}'");
		}
		if (found.size() < 1) {
			return null;
		}
		return found.get(0);
	}
	/**
	 * Find a ProjectArea by fully qualified name The name has to be a fully
	 * qualified name with the full path e.g. "JKE Banking(Change
	 * Management)/Business Recovery Matters"
	 * 
	 * @param name
	 * @param processClient
	 * @param monitor
	 * @return
	 * @throws TeamRepositoryException
	 */
	public static IProjectArea findProjectAreaByFQN(String name, IProcessClientService processClient,
			IProgressMonitor monitor) throws TeamRepositoryException {
		IProcessArea processArea = findProcessAreaByFQN(name, processClient, monitor);
		if (null != processArea && processArea instanceof IProjectArea) {
			return (IProjectArea) processArea;
		}
		return null;
	}
	/**
	 * Find a ProcessArea by fully qualified name The name has to be a fully
	 * qualified name with the full path e.g. "JKE Banking(Change
	 * Management)/Business Recovery Matters"
	 * 
	 * @param name
	 * @param processClient
	 * @param monitor
	 * @return
	 * @throws TeamRepositoryException
	 */
	public static IProcessArea findProcessAreaByFQN(String name, IProcessClientService processClient,
			IProgressMonitor monitor) throws TeamRepositoryException {
		URI uri = getURIFromName(name);
		return (IProcessArea) processClient.findProcessArea(uri, IProcessItemService.ALL_PROPERTIES, monitor);
	}
	/**
	 * URI conversion to be able to find from a URI
	 * 
	 * @param name
	 * @return
	 */
	public static URI getURIFromName(String name) {
		URI uri = URI.create(name.replaceAll(" ", "%20"));
		return uri;
	}
	/**
	 * Removes all components from a workspace connection
	 * 
	 * @param workspaceConnection
	 * @param monitor
	 * @throws TeamRepositoryException
	 */
	@SuppressWarnings("rawtypes")
	private void removeAllCompoentsFormWorkspaceConnection(IWorkspaceConnection workspaceConnection,
			IProgressMonitor monitor) throws TeamRepositoryException {
		// Remove all components
		List wsComponents = workspaceConnection.getComponents();
		for (Object comp : wsComponents) {
			IComponentHandle cHandle = (IComponentHandle) comp;
			workspaceConnection.applyComponentOperations(
					Collections.singletonList(workspaceConnection.componentOpFactory().removeComponent(cHandle, false)),
					true, monitor);
		}
	}
	/**
	 * Adds components to a workspace connection
	 * 
	 * @param workspaceConnection
	 * @param extComponents
	 * @param monitor
	 * @return
	 * @throws TeamRepositoryException
	 */
	private IWorkspaceConnection addComponentsToWorkspaceConnection(IWorkspaceConnection workspaceConnection,
			HashMap<String, IComponentHandle> extComponents, IProgressMonitor monitor) throws TeamRepositoryException {
		// Add new components
		Set<String> componentNames = extComponents.keySet();
		for (String compName : componentNames) {
			logger.info("\tComponent '{}'", compName);
			IComponentHandle cHandle = (IComponentHandle) extComponents.get(compName);
			workspaceConnection.applyComponentOperations(
					Collections.singletonList(workspaceConnection.componentOpFactory().addComponent(cHandle, false)),
					true, monitor);
		}
		return workspaceConnection;
	}
	private String modifyNameForTests(String name) {
		if (fNamePrefixr != null) {
			return fNamePrefixr + name;
		}
		return name;
	}
	private String normalizeName(String name) {
		if (fNamePrefixr != null) {
			return name.substring(fNamePrefixr.length());
		}
		return name;
	}
	private void setComponentNameModifier(String fNameModifier) {
		this.fNamePrefixr = fNameModifier;
	}
	@SuppressWarnings("unused")
	private void showProgress() {
		fProgress++;
		if (fProgress % 10 == 9) {
			System.out.print(".");
		}
	}
}